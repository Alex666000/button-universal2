             2 занятие (map useState() callback filter фильтрация элементов):

/*Алгоритм: создаем слушатель =  колбек на кнопке, создаем функцию = хозяина с заглушкой console.log - прокидываем пропс = функцию созданную - типизируем в PropsType функцию - вернет void всегда - колбека в БЛЛ, вызываем фукцию хозяина и передаем хозяину свои данные - в БЛЛ создаем useState для хранения состояния и в функции вызываем setFilter например для фильтрации,*/
- Мы передаем через вызов функции хозяина название кнопки "All Active или Completed" - это назхвание придет в параметр функции хозяина (при удалении передаем id и производит фильрацию сравнение id и делается отсеивание = удаление элемента из массива данных)
- Фильтр как дуршлаг: мы присваиваем сначала все задачи а потом фильруем только то что надо и прокидываем фильрованное в пропсы в низ кнопкамю Фильтрация значит "подставить дуршлаг"
- Как кнопки подключить к "дуршлаку":
//выбрали все таски где isDone === true (выбрали только "макароны") и прокидываем в пропсы:
    let colander = tasks

    // (Если из кнопки пришло "Active" то дуршлаг заливай isDone === true)
    if (filterValue === 'Active') {
        colander = tasks.filter(t => t.isDone)
    }
    // (Если из кнопки пришло "Completed" то дуршлаг заливай isDone === false)
    if (filterValue === 'Completed') {
        colander = tasks.filter(t => !t.isDone)
    }
     <Todolist
                    title={'Todo1'}
                    // отфильтрованные таски перепрокунули..."подставили дуршлаг"
                    tasks={colander}
                    removeTask={removeTask}
                    chahgeFilter={chahgeFilter}
                />

чтобы убрать конфликт filterValue так как вне области видимости - делаем useState():
let [filter, setFilter]

// Для каждой функции делается свой useState()
